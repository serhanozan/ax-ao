package de.ax.log.aggregation.main;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import de.ax.log.aggregation.model.LogEntry;
import de.ax.log.aggregation.model.ProcessSeverity;
import de.ax.log.aggregation.util.LogEntryDeserializer;

public class Aggregator {

	private Map<Integer,LocalDateTime> processStartMap;
	private Map<Integer,LocalDateTime> processEndMap;
	private Map<Integer,ProcessSeverity> maxSeverityMap;
	private Map<Integer,LinkedList<String>> processHostsMap;
	private int longestProcessId;
	private long longestDuration;
	
	public Aggregator() {
		processStartMap = new HashMap<>();
		processEndMap = new HashMap<>();
		maxSeverityMap = new HashMap<>();
		processHostsMap = new HashMap<>();
	}
	
	/**
	 * Reads the log file, which is full of log entries generated by many clusters, 
	 * and generates a report .
	 * 
	 * @param path The path to the input log file
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public void aggregate(String path){
		FileInputStream inputStream = null;
		Scanner sc = null;
		if(path == null || path.isEmpty()) {
			System.out.println("The path is malformed!");
		}
		try {
			inputStream = new FileInputStream(path);
		    sc = new Scanner(inputStream, "UTF-8");
		    LogEntry logEntry;
		    Gson gson = new GsonBuilder().registerTypeAdapter(LogEntry.class,new LogEntryDeserializer()).create();
		    LocalDateTime tempDate = null;
		    ProcessSeverity maxSeverity = null;
		    LinkedList<String> hostList = null;
		    longestDuration = Long.MIN_VALUE;
		    longestProcessId = 0;
		    long duration = 0l;
		    while (sc.hasNextLine()) {
		        String line = sc.nextLine();
		        logEntry = gson.fromJson(line, LogEntry.class);
		        
		        tempDate = processStartMap.get(logEntry.getProcessId());
		        if(tempDate == null || logEntry.getTimestamp().compareTo(tempDate) < 0 ) {
		        	processStartMap.put(logEntry.getProcessId(), logEntry.getTimestamp());
		        }
		        tempDate = processEndMap.get(logEntry.getProcessId());
		        if(tempDate == null || logEntry.getTimestamp().compareTo(tempDate) > 0 ) {
		        	processEndMap.put(logEntry.getProcessId(), logEntry.getTimestamp());
		        }
		        duration = Duration.between(processStartMap.get(logEntry.getProcessId()), processEndMap.get(logEntry.getProcessId())).toMillis();
		        if(duration > longestDuration) {
		        	longestProcessId = logEntry.getProcessId();
		        	longestDuration = duration;
		        }
		        maxSeverity = maxSeverityMap.get(logEntry.getProcessId());
		        if(maxSeverity == null || logEntry.getSeverity().compareTo(maxSeverity) > 0 ) {
		        	maxSeverityMap.put(logEntry.getProcessId(), logEntry.getSeverity());
		        }
		        hostList = processHostsMap.get(logEntry.getProcessId());
		        if(hostList == null) {
		        	hostList = new LinkedList<>();
		        }
		        hostList.add(logEntry.getHost());
		        processHostsMap.put(logEntry.getProcessId(), hostList);
		    }

		    System.out.println("The total number of processes is " + processStartMap.size() + prettyPrintArray(processStartMap.keySet().toArray()));
	        System.out.println();
	        System.out.println("The longest process is " + longestProcessId + "(" + milisToDays(longestDuration) + " days)");
	        System.out.println();
	        Iterator<Entry<Integer, ProcessSeverity>> it = maxSeverityMap.entrySet().iterator();
	        while (it.hasNext()) {
	            Entry<Integer,ProcessSeverity> pair = (Entry<Integer, ProcessSeverity>) it.next();
            	System.out.println("Maximum severity for process " + pair.getKey() + " : " + pair.getValue());
	        }
	        System.out.println();
	        Iterator<Entry<Integer, LinkedList<String>>> it2 = processHostsMap.entrySet().iterator();
	        while (it2.hasNext()) {
	            Entry<Integer,LinkedList<String>> pair = (Entry<Integer, LinkedList<String>>) it2.next();
            	System.out.println("Number of hosts for process " + pair.getKey() + " : " + pair.getValue().size() + prettyPrintArray(new HashSet<>(pair.getValue()).toArray()));
	        }
	        
		    if (sc.ioException() != null) {
		        throw sc.ioException();
		    }
		}catch(Exception ex) { 
			System.out.println("An exception occured while trying to process the file!");
			System.out.println(ex.getMessage());
		}finally {
		    cleanup(inputStream,sc);
		}
	}

	/** Private method to free resources*/
	private void cleanup(FileInputStream inputStream, Scanner sc) {
		try {
			if (inputStream != null) {
		        inputStream.close();
		    }
		    if (sc != null) {
		        sc.close();
		    }	
		} catch (IOException ex) {
			System.out.println("An exception occured while trying to close the input stream!");
			System.out.println(ex.getMessage());
		}
	}

	/**
	 * @return the processStartMap
	 */
	public Map<Integer, LocalDateTime> getProcessStartMap() {
		return processStartMap;
	}

	/**
	 * @return the maxSeverityMap
	 */
	public Map<Integer, ProcessSeverity> getMaxSeverityMap() {
		return maxSeverityMap;
	}

	/**
	 * @return the processHostsMap
	 */
	public Map<Integer, LinkedList<String>> getProcessHostsMap() {
		return processHostsMap;
	}

	/**
	 * @param processEndMap the processEndMap to set
	 */
	public void setProcessEndMap(Map<Integer, LocalDateTime> processEndMap) {
		this.processEndMap = processEndMap;
	}

	/**
	 * @return the longestProcessId
	 */
	public long getLongestDuration() {
		return longestDuration;
	}
	
	/**
	 * @return the longestProcessId
	 */
	public int getLongestProcessId() {
		return longestProcessId;
	}

	private static long milisToDays(long longestDuration) {
		return longestDuration/(60*60*24*1000);
	}
	
	private static String prettyPrintArray(Object[] array) {
		return Arrays.toString(array).replace('[', '(').replace(']', ')').replaceAll(" ", "");
	}

}
